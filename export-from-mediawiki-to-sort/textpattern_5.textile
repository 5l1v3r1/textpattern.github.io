\n"stop":/home/www/zendstudio/dokuwiki/bin/lib/exe/fetch.php?id=&media=stop

Textpattern 5 (also known as TXP5) is a rewrite of Textpattern version 4. It is based on the "Spark/Plug Framework]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:code.google.com_p_sparkplug-framework developed by Sam Weiss.

Textpattern 5 development is hosted at the "Textpattern 5 Google Code site]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:code.google.com_p_textpattern5. Developers from both in and outside the Textpattern user community are invited to participate.

Progress reports and notes on Textpattern 5 will be posted on the "Textpattern Blog]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:textpattern.com_weblog. There are also open discussions at the Textpattern forum ("example]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:forum.textpattern.com_viewtopic.php&id=35334).

h3(sectionedit1#textpattern_5_developer_guidelinesadmin_side). Textpattern 5 Developer Guidelines: Admin side

h4(#setting_up_a_dev_environment). Setting up a dev environment

Firstly you will need to verify that Mercurial is installed and available on your web server of choice, and of course a virtual server so you can test whatâ€™s going on in your browser. We use local.txp5.com. For help with setting up Mercurial and/or virtual servers, Google is your friend. There are many fine video tutorials on Youtube as well ("Mercurial example]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:www.youtube.com_watch&v=F3EPd1nCFh8, "virtual server example]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:www.youtube.com_watch&v=UpW5yvxBI3U)

There are two elements to Textpattern 5: The "Spark/Plug Framework]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:www.google.com_url&q=http%3A%2F%2Fcode.google.com%2Fp%2Fsparkplug-framework%2Fsource%2Flist The "Textpattern 5 Google Code site]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:www.google.com_url&q=http%3A%2F%2Fcode.google.com%2Fp%2Ftextpattern5%2Fsource%2Flist

If you intend to work locally you need to use Mercurial to check out the code from both the above links and put them side-by-side in your docroot web directory (wherever that is in your server).

h5(#mercurial_google_code_workflow_description). Mercurial / Google Code Workflow Description

You should create a clone of textpattern5 directly on the Google Code pages, check it out to your local environment, work on your mods, push them to your clone and then submit a pull request for us to merge your changes into the core.

Once you have pulled the code down, use it with a fresh database from a clean install of the latest Textpattern 4.x release. For the meantime we are using the same tables: they will be incrementally altered as necessary during development. Spark/Plug supports MySQL as well as other databases such as SQLite, so choose which you prefer.

The next step is to visit your local textpattern5/config and duplicate

bc(code). admin-config-dist.php


and

bc(code). site-config-dist.php


. Call them

bc(code). admin-config.php


and

bc(code). site-config.php


respectively. Ensure you *do not* put these under Mercurialâ€™s control (Read "how to exclude files from Mercurial's control]":/home/www/zendstudio/dokuwiki/bin/doku.php?id=http:stackoverflow.com_questions_3935179_exclude-directories-from-control-mercurial).

Edit

bc(code). admin-config.php


next and change the following settings:

<ul>
<li>bc(code). sparkplug_dir: /full/path/to/sparkplug-framework/sparkplug

</li>
</ul>

Edit

bc(code). site-config.php


and change the following settings:

<ul>
<li>bc(code). use_index_file


<p>: set to false if your web server supports clean URLs</p></li>
<li>bc(code). adapter


<p>: if you are using something other than MySQL</p></li>
<li>bc(code). dsn


<p>: the database type and name you are using</p></li>
<li>bc(code). username


<p>: the user account assigned to the database (must have all privs)</p></li>
<li>bc(code). password


<p>: the password for database access</p></li>
</ul>

You should then be able to browse to

bc(code). textpattern5/admin


in your browser and see Textpattern 5 running. A version of these instructions (with more detail on commands to use) can also be found in the Google Code repository.

h4(#the_mvc_file_system_as_it_relates_to_txp_5). The MVC file system as it relates to Txp 5

Compare the current Textpattern version 4 admin-side folder structure:

<ul>
<li>bc(code). /include/txp_admin.php


<p>- renders the entire Admin:Users tab and its database interaction</p></li>
<li>bc(code). /include/txp_page.php


<p>- renders the entire Presentation:Pages tab and its database interaction</p></li>
<li>...</li>
</ul>

With Txp 5 things look very different, as the tasks to interact with any page are split into the distinct M-V-C phases that take place:

<ul>
<li>bc(code). /core/admin/controllers/admin.php


<p>- handles any URLs of the format '/admin/action/...'</p></li>
<li>bc(code). /core/admin/models/users.php


<p>- handles database interaction for the Admin:Users tab</p></li>
<li>bc(code). /core/admin/views/admin/users.php


<p>- renders the Admin:Users UI content only</p></li>
<li>bc(code). /core/admin/controllers/presentation.php


<p>- handles any URLs of the format '/presentation/action/...'</p></li>
<li>bc(code). /core/admin/models/pages.php


<p>- handles database interaction for the Presentation:Pages tab</p></li>
<li>bc(code). /core/admin/views/presentation/pages.php


<p>- renders the Presentation:Pages UI content only</p></li>
<li>...</li>
</ul>

In addition:

<ul>
<li>bc(code). /core/admin/views/default.php


<p>- renders a common template for ALL tabs, from &lt;!DOCTYPE to &lt;/html&gt;</p></li>
<li>bc(code). /core/admin/views/default_form.php


<p>- renders a common layout for ALL UI content (the bit between header and footer)</p></li>
</ul>

The difference is subtle in terms of what we see on the screen but very different behind the scenes insofar as we should strive for commonality across tabs if possible. That is, in the code we only need to deviate from the default view if a tab really, really requires it. i.e. if that tab is massively different from the norm.

Now, while we could have a dedicated View per tab, we should aim for commonality across tabs to make the code simpler (and probably faster). We can then rely on the framework to do the heavy lifting.

With that goal in mind we want to try and minimize the variability between tabs. More on Views later.

h4(#description_of_files_and_directories_in_textpattern_5). Description of Files and Directories in Textpattern 5

<ul>
<li>bc(code). /admin


<p>:</p>
<ul>
<li>bc(code). /js


<p>: holds admin-wide javascript files</p></li>
<li>bc(code). /theme


<p>: admin-side theme directories, one per theme, containing CSS and images</p></li>
<li>bc(code). index.php


<p>: main admin-side starting point for rendering the interface</p></li>
</ul>
</li>
<li>bc(code). /config


<p>: the configuration files as mentioned above</p></li>
<li>bc(code). /core


<p>:</p>
<ul>
<li>bc(code). /admin


<p>: the MVC files for the admin interface in three separate directories</p>
<ul>
<li>bc(code). /controllers


<p>: one file per primary tab (a.k.a. â€˜areaâ€™ in Txp 4-speak)</p></li>
<li>bc(code). /models


<p>: one file per tab to hold the DB interaction</p></li>
<li>bc(code). /views


<p>: one dir per primary tab, then one file per secondary tab to render that tabâ€™s content</p></li>
<li>bc(code). default.php


<p>: default tab layout</p></li>
<li>bc(code). header.php


<p>: the tab navigation system and page bar (equivalent to pagetop() in Txp 4)</p></li>
<li>bc(code). footer.php


<p>: the page footer (equivalent to end&#95;page() in Txp 4)</p></li>
<li>bc(code). notify.php


<p>: the message display area</p></li>
<li>bc(code). default_form.php


<p>: template for rendering the input fields in the main content area on each tab</p></li>
<li>bc(code). app.php


<p>: the app jumpoff point / install validator / plugin loader</p></li>
</ul>
</li>
<li>bc(code). /shared


<p>: library classes that both admin-side and public-side share</p>
<ul>
<li>bc(code). txp_admin_controller.php


<p>: defines the tab structure and the app-wide default HTML form</p></li>
<li>bc(code). txp_base.php


<p>: version and version checker</p></li>
<li>bc(code). /languages


<p>: lang files for the interface</p></li>
</ul>
</li>
</ul>
</li>
</ul>

A lot of the really cool Spark/plug functionality is down to naming convention. This will be covered in the subsequent topics where necessary.

h4(#subscribe_notify_aka_callback_event_register_callback). Subscribe / notify (a.k.a. callback&#95;event / register&#95;callback)

Textpattern 5 uses the notion of subscribing to events / steps in much the same way as Txp4. But there are differences.

Callbacks are no longer just strings, they are colon-separated paths. For example, the path:

bc(code). txp:site_change:presentation:styles:edit


refers to the admin-sideâ€™s Presentation→Style tab (Txp4â€™s â€˜eventâ€™), and the â€˜editâ€™ action (Txp4â€™s â€˜stepâ€™). Thus if you raised a callback like this:

bc(code). $this->observer->observe(
   array($this, 'my_custom_style_edit'),
   'txp:site_change:presentation:styles:edit'
);


it would call

bc(code). my_custom_style_edit()


when anyone clicked to edit a Stylesheet.

The major departure from Textpattern 4 is that you can elect to subscribe to any path in the hierarchy and be notified of all events below it. Thus you could subscribe to:

bc(code). txp:site_change:presentation:styles


and you would be notified when *any* action (add, edit, delete, ...) on the Presentation→Styles tab was taken. This helps plugin authors target things more easily too and provides more flexibility over Txp 4.

In addition to â€˜txpâ€™ events, Spark/Plug has its own internal event paths that you can observe. These are:

*SparkAuthController*

login

logout

*SparkLang*

load

*SparkSessionStore*

validate&#95;ip

_fail_

_success_

*warning*

SparkValidator

_norule_

*Spark*

cache

_flush_

_request&#95;flush_

manufacture

*SparkPageCache*

request&#95;flush

request&#95;disable

*SparkPlug*

redirect

_before_

_after_

_pre_

_post_

*SparkView*

render

_before_

_after_

_pre_

_post_

*SparkApplication*

run

_exception_

_exit_

_before_

_after_

_pre_

_post_

display

_before_

_after_

_pre_

_post_

dispatch

_before_

_after_

_pre_

_post_

h4(#textpattern_5_mvc_components_in_depth). Textpattern 5 MVC Components in Depth

h5(#models). Models

Models contain database interaction. They should not care about such things as “display columns” and “required fields”: they should be concerned only with efficiently fetching and storing data on behalf of controllers.

One quick mental test for whether something should go in the model: if you were to create an alternate data store that uses XML files instead of a database, would you need to change this model code?

The best place to see what database interaction methods are available is in

bc(code). sparkplug/plugs/sparkdb/sparkdb.php


. As well as the usual

bc(code). selectRows()


,

bc(code). insertRow()


,

bc(code). deleteRow()


, etc, there are lots of useful

bc(code). build*()


methods for combining and conjoining query parts. Use them!

h5(#controllers). Controllers

Controllers contain instructions on what actions to take when a particular URL is detected.

Only methods prefixed with

bc(code). action_


can run when the corresponding URL is accessed. e.g.

bc(code). action_pages()


inside

bc(code). /controllers/presentation.php


is automatically called when the URL is

bc(code). /presentation/pages


. Usually this method is a jumpoff that tests the URL parameters and calls a dedicated method to handle that action (a.k.a.â€˜stepâ€™ in Txp 4 jargon).

bc(code). $params['pv']


is essentially the

bc(code). $_POST


array which can be tested and checked.

You usually start each action method with:

bc(code). $this->getCommonVars($vars);
   self::$lang->load('name-of-tab');


The first sets up the default things like app title, tab title, the selected tab name, body class, default language, locale, file paths, the tab names, etc: that is, the stuff from site-config.php and a few other handy items (see

bc(code). /core/shared/txp_admin_controller.php


). Feel free to augment this list on a tab-by-tab basis or add any sensible default values to the

bc(code). GetCommonVars()


method in

bc(code). txp_admin_controller.php


.

bc(code). self::$lang


is available to grab strings from the currently set language (default:

bc(code). en_GB


). Use the

bc(code). load()


method to read the strings in and the

bc(code). get()


method to request a particular string translation, passing any replacement vars as subsequent parameters. Whereas Txp 4 uses one file per language, Txp 5 uses one *directory* per language so we could separate them into smaller files if desired. At the moment itâ€™s one file per tab but that might get a little unwieldy so maybe one per primary tab (presentation, admin, content) is better. It will depend how the RPC server is used (if at all).

bc(code). $vars


holds stuff you want the view to have access to. Each key gets extracted into a variable in the view. e.g.

bc(code). $var['notice']


becomes

bc(code). $notice


in the view.

Field-level validation is handled as a parameter to each form field. For example,

bc(code). required_if[copy]


can automatically throw error messages if the conditions are not met, in this case if the field is not filled out when the button named â€˜copyâ€™ is hit. Pipe-delimit the rules.

Spark/Plug defines some key validation rules but you can define your own. See the methods beginning

bc(code). validate_


in

bc(code). /sparkplug/plugs/sparkvalidator/sparkvalidator.php


(and for a quick list, consult

bc(code). /sparkplug/languages/en_US/spark_validator.php


file which contains the error messages thrown when certain conditions fail).

If you want to validate form fields, add a

bc(code). ->validator($this)


to your form. For example:

bc(code). $form = $this->newForm($isNew ? 'style_new' : 'style_edit', 'Style')
     ->validationCallback(array($this, $isNew ? '_validateForm_newStyle' : '_validateForm_editStyle'))
     ->processingCallback(array($this, $isNew ? '_processForm_newStyle' : '_processForm_editStyle'))
     ->validator($this)
         ;


Then, any methods in the controller that begin with

bc(code). validate_


automatically become validation rules in input fields. e.g.

bc(code). validate_abc


means that you can use â€˜abcâ€™ like this in an input field:

bc(code). $form->text('name', 'Some label:', NULL, NULL, true, 'abc');


If the

bc(code). validate_abc()


method returns true/false then it indicates a pass/fail condition. If it returns a string then that is used as the value for the input. In this way you can sanitize input data or indicate success/failure. Some central validation routines have been imported from Txp 4 and put in

bc(code). /core/shared/input.php


but they need work yet.

Flash message are items that only exists for the next page request, i.e. to pass stuff like error messages to the next page. So:

bc(code).    <code>$this->session->flashSet('notice', self::$lang->get('css_created', $this->newStyleName));


&lt;/code&gt; will flash a â€˜noticeâ€™ message up on completion of the current task. Defined types so far are:

* notice
* warning
* error

You can either use

bc(code). $this->session->flashGet(â€˜typeâ€™);


to retrieve the latest message thatâ€™s been set or just assign the message directly to the

bc(code). $vars[message_type]


array, e.g.

bc(code). $vars[â€˜noticeâ€™] = â€œAction doneâ€


. Itâ€™s up to the logic whether you prefer one or the other, bearing in mind that

bc(code). $this->redirect()


can be used to jump to a different action step, which may or may not automatically render notices that have not been explicitly set using

bc(code). $this->session->flashSet()


. Consult

bc(code). /core/admin/views/notify.php


to see how display of the messages is handled.

A few other rules and tips:

<ol>
<li>Donâ€™t use inline forms because you wonâ€™t benefit from the built-in CSRF protection</li>
<li>bc(code). $form->input()


<p>sets up all form fields.</p></li>
<li>bc(code). $form->defaults()


<p>handles error cases or empty URL vars</p></li>
<li>bc(code). $form->run()


<p>'s parameters are callbacks for additional checks.</p></li>
<li>bc(code). $this->render('default', $vars)


<p>is usually the last line in any controllerâ€™s action sequence to pass control to the View to draw the interface</p></li>
</ol>

And a couple of handy methods:

<ul>
<li>bc(code). $this->dropParam


<p>: remove an item from the beginning of an array. Handy for dropping the action from controller URLs ready to pass to the action method.</p></li>
<li>bc(code). $this->redirect


<p>: useful for jumping to another action. For example, after copying an item you can jump to the â€˜editâ€™ action for the clone. Paths for the various screens are held in</p>
bc(code). $vars[â€˜urlsâ€™]


<p>but note they are not configurable as that would break the controllers.</p></li>
</ul>

h5(#views_via_controller_vars). Views (via controller vars)

Views render the interface as seen on-screen. Weâ€™re validating to HTML 5, at least as far as the spec has been ratified.

Views should be as human-readable as possible and contain mostly HTML, i.e. *no heredoc*! Escape into and out of PHP at will using

bc(code). <?= â€¦ ?>


to echo contents of variables, and

bc(code). <? foreach($thingy as $item) ?>


or

bc(code). <? if (some condition): ?>


[ note the colon at the end ] with corresponding

bc(code). <? endforeach; ?>


and

bc(code). <? endif; ?>


lines.

Try and keep form field names the same as the column in the database that each represents.

To add HTML form fields to the interface, create a new form in the controller:

bc(code).  <code>$form = $this->newForm(â€˜form_nameâ€™, â€˜labelâ€™)


&lt;/code&gt; chain some validator/processor methods to it as shown above, then chain form fields to it:

bc(code).   ->textArea(
        â€˜field_nameâ€™,
        â€˜labelâ€™,
        â€˜default_contentâ€™,
        array(â€˜additional_attributeâ€™ => â€˜valueâ€™),
        required (true/false),
        â€˜validation_rulesâ€™
    ) 
  ->submit(
        â€˜field_nameâ€™,
        â€˜labelâ€™,
        â€˜default_contentâ€™,
        array(â€˜additional_attributeâ€™ => â€˜valueâ€™),
        default_if_empty (true/false),
    ) 


and so on. See

bc(code). /sparkplug/plugs/sparkform/sparkform.php


for the available HTML field methods.

Assign the

bc(code). $form


to

bc(code). $vars[â€˜formâ€™]


so the

bc(code). default_form.php


can access it. The view can then iterate over the form field elements and display them in the primary nav area. Lists of things that appear in the secondary nav area can be assigned likewise so they can be iterated over and displayed with inline PHP. No naming convention has been set yet for this, but it would probably be prudent to pick one.

By default, each form field will be rendered as a list item (li) inside an unordered list. The class of the list item will be the fieldâ€™s input type, e.g.

bc(code). text


,

bc(code). hidden


,

bc(code). textarea


,

bc(code). submit


, etc. If you want to group items, add a

bc(code). ->fieldset_open(â€˜nameâ€™)


and

bc(code). ->fieldset_close()


pair around the elements in question. The grouped items will be rendered inside their own unordered list (ul) and will be inline instead of stacked above each other. If you want to deviate from this layout you can elect not to use the default form and use your own instead, but the more tabs that can use the default form, the less code we need to write. If the default form needs tweaking so it is applicable to more than one type of tab then feel free to modify it to suit.

Bear in mind that the goal of the interface is to have each major element directly addressable from CSS/javascript without descendant selectors. If we can use existing class names and IDs from Txp 4 (where they make sense) then do so. These will be augmented or replaced by aria roles and HTML 5 elements where appropriate.

Views can

bc(code). render()


views, and all sub-views get access to $vars.

