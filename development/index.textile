---
layout: document
category: development
published: true
title: "Textpattern plugin development"
tags:
  - development 
  - plugins
---

h1. Textpattern plugin development

This information is for those who are thinking about developing Textpattern plugins.

On this page:

* "Disclaimer":#sec1
* "Developer rules of the road":#sec2
** "Avoid reinventing the wheel":#sec2-1
** "Do it the Textpattern way":#sec2-2
** "Write clear and concise plugin help":#sec2-3
* "What is a plugin?":#sec3
** "Functional categories":#sec3-1
** "Public-side plugins":#sec3-2 (with tutorial)
** "Admin-side plugins":#sec3-3 (with tutorial)
* "Register your plugin developer prefix":#sec4
* "How plugins are loaded":#sec5
* "Functions and arguments":#sec6
** "Public-side functions and arguments":#sec6-2
** "Admin-side functions and arguments":#sec6-2
*** "Function: @pluggable_ui()@":#sec6-2-1
*** "Function: @register_callback()@":#sec6-2-1
* "Callbacks":#sec7
** "Adding admin-side panel elements":#sec7-1
** "Removing admin-side panel elements":#sec7-2
** "Modifying admin-side panel elements":#sec7-3
* "Variables, classes, and constants":#sec8
* "Plugin lifecycle management and preferences":#sec9
* "Implementation resources":#sec10
* "Getting help":#sec11
* "External reading":#sec12

h2(#sec1). Disclaimer

Before you embark on this journey, understand that core developers put a lot of effort into maintaining backwards compatibility within the development branch of Textpattern itself, but that does not guarantee your plugins will continue to work as intended after new versions of Textpattern are released. Sometimes new development directions -- like what might come as we head to version 4.6 and later -- require making changes that affect backwards compatibility. As a plugin developer, it is your responsibility to ensure your plugins work against core code at point of every future Textpattern release.

h2(#sec2). Developer rules of the road

More like three strong recommendations, meant to help ensure that you're producing plugins people will want to use. And that's the whole point, right?

h3(#sec2-1). Avoid reinventing the wheel 

Before you start developing, spend some time researching what plugins exist, what functionality they provide, and how well they're working for people (often indicated by how popular they are). While reinventing the wheel is a good way to learn, building a plugin that does what another plugin already does isn't going to be immediately useful unless it's _extremely_ innovative in some way. If you decide to throw caution to the wind and reinvent the wheel anyway (perhaps stepping on toes in the process), make sure you're ready to raise the bar. Somebody has to eventually.

Here's the visible approach to plugin conception that can help you make a good choice... 

When plugin ideas aren't conceived quietly in the minds of individuals and built to fruition without a lot of fanfare (a path usually taken when a developer needs the functionality regardless of whether the community does or not), they often begin as a core "feature idea":http://forum.textpattern.com/viewforum.php?id=2 ("a shunned one":http://docs.textpattern.io/development/plugin-vs-core), or "plugin discussion":http://forum.textpattern.com/viewforum.php?id=13. Bouncing plugin ideas off the community first is a good way to gauge whether a plugin idea has merit -- the more interest and constructive feedback you get, the more likely the plugin is worth building.

h3(#sec2-2). Do it the Textpattern way

Do it the “Textpattern's way” from the start by using Textpattern functions (talked about later), because they already work efficiently. Your goal should be to emulate Textpattern as you expand its capabilities, otherwise you run the risk of your plugin feeling foreign or out of place, and perhaps not working well with other plugins. Further, some functions are in place to assist with keeping Textpattern secure and working regardless of host server settings, and you don't want to interfere with that kind of thing.

h3(#sec2-3). Write clear and concise plugin help 

Don't be one of _those_ developers that assumes everyone knows what you know -- the opposite is true. People won't use your plugin (innovative or not) if you don't explain how. You can avoid fielding a lot of unnecessary questions in the support forum and empower users by producing good plugin user instructions to begin with.

Make use of the "Plugin user-help guidelines":http://docs.textpattern.io/development/plugin-user-help-guidelines to ensure your plugin instructions are consistently structured and properly formatted.

If you include screenshots in your plugin help, keep them updated with UI changes. Nothing looks worse or is more confusing than outdated screenshots that don't match the help copy.

h2(#sec3). What is a plugin?

This documentation focuses on the technological aspects of plugins, but you should also understand the "philosophy of core development":http://docs.textpattern.io/development/plugin-vs-core, as it relates to why few of the functional capabilities provided by plugins are ever integrated into core code.

In general, a "plugin" is a container for any kind of PHP code. The code can be a few lines of PHP, or _function_ and _class_ definitions.[1] Defining functions in the plugin is a common and easy way to start out, as they can be called from templates. But more advanced ways exist for plugins to influence Textpattern behaviour.

fn1. You can see the code for any installed plugin by clicking its name in the table on the **"Plugins":http://docs.textpattern.io/administration/admin/plugins-panel** panel, or by installing and using "ied_plugin_composer":http://textpattern.org/plugins/588/ied_plugin_composer.

h3(#sec3-1). Functional categories

Plugins can be categorised in three functional ways:

* “On demand” (providing tags for __pages__ and __forms__)
* “Up front” (intercepting page requests; either all or those having special characteristics)
* “In between” (using Textpattern hooks to automatically change or add behaviour)

The most practical (and most popular) plugins fall into more than one category, because a plugin is really nothing more than a container for code. If it provides functionality in multiple ways, it's likely providing more benefit to the user.

Plugins can also be public-side or admin-side, or be one of several types that correspond to all of the above (see __How plugins are loaded__ later.)

h3(#sec3-2). Public-side plugins

Public-side (aka "client-side" or "front-side") plugins are those that enable content output on the front-side of a website, often through specialised tags, which a website designer can use interchangeably with Textpattern's core tags and HTML. These kinds of plugins don't have much in the way of requirements, thus are great plugins to try building when getting started with Textpattern plugin development.

* "Public-side plugin tutorial":http://docs.textpattern.io/development/public-side-plugin-tutorial -- A basic tutorial to learn the ropes of the easiest kind of plugin to build.

h3(#sec3-3). Admin-side plugins

Admin-side plugins provide site administrators and designers the ability to alter the "admin-side":http://docs.textpattern.io/administration/ UI and/or functionality in some way. 

Admin-side plugins often make use of the **"Extensions":http://docs.textpattern.io/administration/extensions/** region. In other words, if an admin-side plugin is designed to provide a user with special preferences, search mechanisms, functional controls, and so forth, they would be made available on their own sub-panel under the Extensions region.

* "Admin-side plugin tutorial":http://docs.textpattern.io/development/admin-side-plugin-tutorial -- A basic tutorial to get acquainted with the tricker kinds of plugins to build.

h2(#sec4). Register your plugin developer prefix

All hopeful plugin developers must have a "plugin developer prefix":http://docs.textpattern.io/development/registered-textpattern-developer-prefixes.

When developing your plugins, you will apply your prefix in:

* The names of PHP classes, functions, and global variables in the plugin's code.
* The database table and indices names.
* The names of stored preferences in the @_txp_prefs_@ table and/or the @$prefs array;@.
* Any global JavaScript variables or function names you use for modifying the backend or adding features to the front-end.
* IDs and, to some extent, classes of HTML elements that you add to the backend interface.[2] 
* URL parameter names. Replace @?foo=bar&baz=1@ with @?abc_foo=bar&abc_baz=1@, where "@abc@" would be your own prefix.

fn2. The exception to this is if an element of your markup is logically similar to an already existing core element and you wish it to be styled in the same way by themes. Doing this saves theme designers from having to write specific rules to target your plugin's markup.

h2(#sec5). How plugins are loaded

Plugins are loaded very early during script execution. It happens in textpattern/publish.php (public-side) and in textpattern/index.php (admin-side). Look out for @load_plugins@ to see where it is happening.

By setting the plugin-type in your plugin you can control how a plugin will be loaded:

* A “*public*” plugin (0) will only be loaded on the public side.
* An “*admin + client*” plugin (1) will be loaded on both public _and_ the admin sides.
* A “*library*” plugin (2) will not automatically load, rather it loads when included/required by other plugins.
* An “*admin*” plugin (3) will only be loaded on the admin side and may _not_ make asynchronous calls.
* An “*admin + AJAX*” plugin (4) will only be loaded on the admin side and may make asynchronous calls.
* An “*admin + public + AJAX*” plugin (5) will be loaded on both the admin and public sides and may make asynchronous calls.

The code of the plugin is then @eval()@ 'ed (or included) within that @load_plugins()@ function, _not_ in the global scope. This means if you need to use global variables, you have to explicitly set them to be global. Functions and classes are always in the “global scope”, so there is no problem with that.

Understanding how plugins are loaded, also shows how you can write “on demand” and “up front” plugins, which were mentioned earlier. Defining a function will make it available as a tag in Textpattern __pages__ and __forms__. Whereas any code that is outside of any function/class definition will be executed right away. You can check for Request-Variables and initiate some action and @exit;@ the execution of the script (for example to serve images or other binary data from within a plugin).

h2(#sec6). Functions and arguments

There are many "functions used in Textpattern":http://phpcrossref.com/xref/textpattern/_functions/ that may be relevant to your plugin development aims. As you learn about them, be aware of the helper functions found in the __"/lib":https://github.com/textpattern/textpattern/tree/master/textpattern/lib__ folder. Here are a few examples of where to look:

* __"txplib_db.php":https://github.com/textpattern/textpattern/blob/master/textpattern/lib/txplib_db.php__ -- for interacting with the Textpattern database
* __"txplib_forms.php":https://github.com/textpattern/textpattern/blob/master/textpattern/lib/txplib_forms.php__ -- to help build various HTML form elements
* __"txplib_html.php":https://github.com/textpattern/textpattern/blob/master/textpattern/lib/txplib_html.php__ -- to help build various other HTML elements
* __"txplib_misc.php":https://github.com/textpattern/textpattern/blob/master/textpattern/lib/txplib_misc.php__ -- various “miscellaneous” functions.

When we talk about *arguments* in these docs, we're referring to the parameters of a given function. For example, say we have the hypothetical function @foo()@. Its signature (or definition), including the arguments (or parameters), might be:

bc. function foo($argument1, $argument2, $argument3, $etc)

The arguments for a given function will vary depending on what your functions are for, and whether you're developing a plugin for the public-side or admin-side.

Two arguments you'll see mentioned a lot in these docs are for _events_ (@$event@) and _steps_ (@$step@). Their position in a function signature varies depending on the function type. You'll see what we mean below when defining the @register_callback()@ and @pluggable_ui@ functions.

See the "Core callbacks reference":http://docs.textpattern.io/development/core-callbacks-reference for all _events_ and _steps_ used to write every possible Textpattern callback.

See the "Admin-side events and steps":http://docs.textpattern.io/development/admin-side-events-and-steps for all the _events_ and _steps_ you might use in admin-side plugins specifically.

h3(#sec6-1). Public-side functions and arguments

It's probably not helpful to make a list of public-side functions. If you're comfortable with PHP, you'll figure things out, and the helper functions mentioned above will get you on your way.

But there are four _events_ (i.e., the @$event@ argument) to be aware of for writing public-side callbacks. These two are mainly for comments and spam-related plugins:

* @comment.save@ -- Gets called after the nonce check passed, but before a plugin is saved.
* @comment.form@ -- Gets called before a comment form is rendered and allows to add to it. 

And these two are useful for introducing your own URI schemas:

* @pretext@ -- Gets called at the beginning of the @pretext()@ function.
* @textpattern@ -- Gets called at the beginning of the @textpattern()@ function. 

In the latter case, for example, imagine building an archive plugin that prevented this URL, __domain.tld/section/archive/__, from returning a 404 error.

h3(#sec6-2). Admin-side functions and arguments

Two functions in particular are notable for admin-side plugins: @register_callback()@ and @pluggable_ui()@. Both of these functions are important for writing admin-side "callbacks":#sec7.

In addition to the "Core callbacks reference":http://docs.textpattern.io/development/core-callbacks-reference, also see the "Admin-side events and steps":http://docs.textpattern.io/development/admin-side-events-and-steps for all the _events_ and _steps_ you might use in admin-side plugins specifically.

h4(#sec6-2-1). Function: @register_callback()@

The @register_callback()@ function is at the core of writing callbacks and can be used for public-side or admin-side plugins depending on how you write it.

The full function definition (signature) looks like this:

bc. function register_callback($func, $event, $step='', $pre=0)

And the indicated *arguments* (or parameters) are:

|_. No. |_. Argument |_. Explanation |
| 1 | @$func@ | The name of the function you coded and want to add to a callback event. |
| 2 | @$event@ | The name of the Textpattern-provided event that you associate your plugin with. |
| 3 | @$step=''@ | **For admin-side plugins only, thus optional.** The _event_ is (disjunctively) divided into steps, so you have the choice of narrowing your plugin to a specific step. |
| 4 | @$pre=0@ | **For admin-side plugins only, thus optional.** By default, this argument is equal to @0@, thus @$func@ is called after the main part of the page is executed and rendered, allowing your function to add things below it, or to manipulate the DOM. If you set this to "1" (@$pre=1@), then @$func@ is called before any part of the page is rendered or executed. This allows you to replace existing panels on the admin-side. |

Also see the "complete list of admin-side events and steps":http://docs.textpattern.io/development/admin-side-events-and-steps.

h4(#sec6-2-2). Function: @pluggable_ui@

The @pluggable_ui@ function is for admin-side plugins solely. The function is used throughout the core and allows you to manipulate the user-interface of the administration side by targeting any panel widgets or their contained controls.[1]

Callbacks written with @pluggable_ui@ have a different signature than those written with other functions. The usually have 4 arguments (and sometimes 5).

|_. No. |_. Argument |_. Explanation |
| 1 | @$event@ | The name of the Textpattern-provided event that you associate your plugin with. |
| 2 | @$step=''@ | The step(s) of the event that you're specifically targeting. |
| 3 | (default markup) | Used if not modified. |
| 4 | (record set) | Returned from the database. |
| 5 | (value) | The value of a named element (e.g., preference setting), indicated by argument 4. |

**Argument #1** is the event passed to your function, usually ends in @_ui@ (for “user interface”) and begins with the event to which it refers. For example, on the **Write** panel the event is @article_ui@, and on the **Files** panel the event is file_ui. Straightforward.

**Argument #2**, the $step, is usually the part of the panel that contains the widget or any of its controls you wish to change. For example, on the Write panel, the Article image control has a $step called article_image and the Custom fields widget has one called custom_fields, and so on.

Arguments 3, 4, and 5 are optional depending on what you're trying to do…

**Argument #3**, if applicable, is the default markup; it will be used if you don’t modify it. Parsing argument #3 allows you to alter what was originally going to be displayed, and then return it. Or you may discard this markup and return your own instead.

**Argument #4**, if applicable, is the record set returned from the database table that pertains to the named _event_.

**Argument #5**, if applicable, is a special case (e.g., when dealing with preference settings) where argument #4 becomes the preference name and argument #5 holds its value.

See "Admin-side user-interface callbacks":http://docs.textpattern.io/development/core-callbacks-reference#sec2-4) in the "Core callbacks reference":http://docs.textpattern.io/development/core-callbacks-reference for more callback options.

fn1. *Attention!* Though it’s possible to completely redesign the HTML markup within the page, you are advised to refrain from doing so with a plugin. Removing and changing admin-side panel elements can make the plugins of other developers who target those DOM elements non-functional. If you must rename selectors (IDs, classes), consider leaving the existing items intact and adding your own, then setting the originals to display:none via CSS.

h2(#sec7). Callbacks

Textpattern makes extensive use of callbacks. [todo:what is a callback?] Hook into these known points to choose where and when your plugins run. The *"Core callbacks reference":http://docs.textpattern.io/development/core-callbacks-reference* provides complete details for all callbacks used in Textpattern, organised by type.

The @register_callback()@ and @pluggable_ui()@ functions mentioned earlier are instrumental in writing callbacks, and especially for administration-related plugins.

Let's put it all together with a few examples using functions and arguments (events, steps, etc) to write callbacks.

h3(#sec7-1). Adding your own admin-side panel elements

There are two ways panel elements can be added to an admin-side panel: as _new_ elements, or as modifications to existing elements.

h4(#sec7-1-1). Adding new elements

In this example, we use the @pluggable_ui()@ function to add text immediately below the **Textile help** link in the **Write** panel. That is where the @extend_col_1@ step puts its markup:

bc.. register_callback('abc_add_text', 'article_ui', 'extend_col_1');

function abc_add_text($event, $step, '', $rs) {
   return 'Hello world!';
}

p. Note there is no third argument because there is no default content to alter.

h4(#sec7-1-2). Adding new elements to existing panel markup

Another way to add elements is to existing markup. For example, to add the url_title below the article's **Title** field, you could do this:

bc.. register_callback('abc_append_item', 'article_ui', 'title');

function abc_append_item($event, $step, $data, $rs) {
   $urlttl = isset($rs['url_title']) ? '&lt;br/&gt;'.$rs['url_title'] : '';

   return $data.$urlttl;
}

p. Notice we return the default markup, @$data@, and tack on our own markup which we read from the record set that was passed to our function.

h3(#sec7-2). Removing admin-side panel elements

In this example, let's say you wanted to remove the **Keywords** field from the **Write** panel. You could hook into the @keywords@ step of the **Write** panel by doing the following:

bc.. register_callback('abc_remove_keywords', 'article_ui', 'keywords');

function abc_remove_keywords($event, $step, $data, $rs) {
   return ' ';
}

p. That's it! If your function returns anything at all (note we return a space character here) then the default markup is dropped in favour of your own markup.

In reality, you probably wouldn't want to do something this drastic unless you were sure there were no other plugins that targeted the **Keywords** field field, such plugins would fail if they couldn't find the element you had destroyed. Hiding the element with CSS using @display:none@ would be a safer/better approach. If this is a problem for you and you feel you must delete the element, you could set your plugin to run at a lower priority (i.e., greater than "5") so other plugins could render their markup _before_ you remove the **Keywords** field.

h3(#sec7-3). Modifying admin-side panel elements

The final mechanism for altering panel elements is good old fashioned search-and-replace, by looking in the default markup for particular items to change. This is the least robust mechanism but it can be very useful at times.

Consider this example, which adds a radio button to the existing button series in the **Write** panel's **Status** widget:

bc.. register_callback('abc_altered_status', 'article_ui', 'status');

function abc_altered_status($event, $step, $data, $rs) {

   $stat = isset($rs['Status']) ? $rs['Status'] : '';

   $new_status = n.t.'&lt;li&gt;'.radio('Status', 6, ($stat == 6) ? 1 : 0, 'status-6').'&lt;label for=&quot;status-6&quot;&gt;Velcro&lt;/label&gt;&lt;/li&gt;';

   $data = str_replace('&lt;/ul&gt;', $new_status.'&lt;/ul&gt;', $data);

   return $data;
}

h2(#sec8). Variables, classes, and constants

**Variables:**

* "Variable list":http://phpcrossref.com/xref/textpattern/_variables/ (via PHP Cross Reference)
* "Accessing global variables":http://www.focusontheclouds.com/home/articles/72/accessing-global-variables-in-textpattern

**Classes:**

* "Classes list":http://phpcrossref.com/xref/textpattern/_classes/ (via PHP Cross Reference)
* "Class in plugins example":http://forum.textpattern.com/viewtopic.php?id=26025

**Constants:**

* "Constants list":http://phpcrossref.com/xref/textpattern/_constants/ (via PHP Cross Reference)

h2(#sec9). Plugin lifecycle management and preferences

Plugins can opt into receiving @plugin_prefs.abc_my_plugin_name@ and @plugin_lifecycle.abc_my_plugin_name@ events. This opt-in is signaled to the core by raising the appropriate bits in @$plugin['flags']@.

@PLUGIN_LIFECYCLE_NOTIFY@ and @PLUGIN_HAS_PREFS@ are human-readable defined bit masks for your coding pleasure. Use them in any appropriate combination (@PLUGIN_LIFECYCLE_NOTIFY | PLUGIN_HAS_PREFS@, etc).

Once you have flagged your intention to use the events, you use the standard @register_callback()@ system to invoke your own code when the event fires:

bc. register_callback('my_prefs_page', 'plugin_prefs.abc_my_plugin_name');

Or:

bc. register_callback('my_install_routine',
   'plugin_lifecycle.abc_my_plugin_name', 'installed'); register_callback('my_delete_routine',
   'plugin_lifecycle.abc_my_plugin_name', 'deleted');
register_callback('my_enable_routine',
   'plugin_lifecycle.abc_my_plugin_name', 'enabled');;
register_callback('my_disable_routine', 
   'plugin_lifecycle.abc_my_plugin_name', 'disabled');

It is worth noting that Textpattern reserves the lower twelve bits of @$plugin['flags']@ for its own use, plugin developers may take advantage of the remaining four (@~PLUGIN_RESERVED_FLAGS@). These might come in handy to trigger some one-time actions, as these bits are copied into the __txp_plugin__ table row for any particular plugin whenever it is uploaded.

h2(#sec10). Implementation resources

Now you know what plugins are, and you're ready to kick plugin ass. You'll probably need some combination of these to see the job through:

**Plugin code template:**

Always use a template when one is available, and there is:

* "Plugin template":https://github.com/textpattern/textpattern-plugin-template
* "Plugin template helper":http://docs.textpattern.io/development/plugin-template-help

**Plugin composer:**

Namely, the "ied_plugin_composer":http://textpattern.org/plugins/588/ied_plugin_composer plugin, as mentioned before. A plugin to build plugins. Ironic, eh? Truth is, this plugin is _extremely_ useful: It allows you to create, code, and document plugins, then publish them in either conventional text format, compressed text format, or exported in the standard template format for sharing with developers or using in the plugin cache directory. This plugin also lets you directly edit plugins that are in the plugin cache directory.

**Plugin user-help template and guidelines:**

When you're coding is done, it's time to write that tight and useful plugin help documentation -- one of the _Developer rules of the road_ mentioned earlier. Ensure your plugin instructions are consistently structured, properly formatted, and easier for users to ... well, use.

* "Plugin user-help guidelines":http://docs.textpattern.io/development/plugin-user-help-guidelines
* "sed_plugin_help_viewer":http://textpattern.org/plugins/612/sed_plugin_help_viewer (A help viewer plugin that you might find... helpful.)

**Code repositories:**

Get your repos here. (Other docs regarding command-line interaction with repos will appear here later.)

* "Fetching development version of Textpattern":http://docs.textpattern.io/development/fetching-dev-version-of-txp (Also addresses which branch or release to use, and where to get old versions.)

**Integration and waypoints:**

These may be useful depending on the kind of plugin you're building. 

* "User role types and privileges":http://docs.textpattern.io/administration/admin/user-role-types-and-privileges (If your plugin will interact with user accounts.)
* "Database schema reference":http://docs.textpattern.io/development/database-schema-reference (If your plugin will need a database table.)
* "Extensions":http://docs.textpattern.io/administration/extensions/ (If your admin-side plugin will provide __Publisher__ controls in it's own panel under **Extensions**.)

**Miscellaneous tools:**

These are "questionable":https://github.com/textpattern/textpattern.github.io/issues/34 until further notice.

* "Generate a list of tags and attributes":http://forum.textpattern.com/viewtopic.php?id=12299 [???]
* "Command-line plugin decoder":http://forum.textpattern.com/viewtopic.php?id=4252 [???]

h2(#sec11). Getting help

If you need a warm shoulder to lean on, subscribe to the "plugin development mailing list":http://lists.textpattern.com/, which might be rather quiet unless you use it. 

The Textpattern Support Forum, notably the "Plugin discussions":http://forum.textpattern.com/viewforum.php?id=13 area, is a good place to post questions too. 

h2(#sec12). External reading

These are external to official documentation. Their status and value is out of our hands, but you may find something useful there. Not a long list, in any case.

* "How to build a Textpattern plugin":http://txptips.com/how-to-build-a-textpattern-plugin

